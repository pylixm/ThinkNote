---
type : post
title : 数据结构与算法 - 链表
categories: [数据结构与算法,] 
series: [数据结构与算法笔记,]
date : 2019-12-18
url: /posts/2019-12-18-link.html 
tags : [数据结构与算法, 链表]
---

## 基本概念

链表，通过“指针”将一组凌塞的内存块串联起来使用的数据结构。

## 分类

### 单链表

单链表构成：

```
-> <data|next> -> <data|next> -> <data|next> -> NULL 
```
- 节点，内存块
- 后继指针，记录下个节点地址的指针
- 头节点，第一个节点
- 尾节点，最后一个节点。最后一个节点的指向是空地址NULL。

### 操作

**查找**

因为链表的地址空间非连续，无法像数组一样根据下标寻址公式来计算地址，只能从头挨个遍历。查询某值的时间复杂度都是O(n)。

**插入**

插入时，我们只需关注节点的指针指向即可，所以时间复杂度为O(1)。

**删除**

删除时，同插入，移动节点指针即可。时间复杂度为O(1)。

### 循环链表

循环链表，是一种特殊的单链表，即最后一个节点的后继指针保存了头结点的内存地址。大致如下：

```
        _______________________________________ 
       ↓                                      |
-> <data|next> -> <data|next> -> <data|next> --
```

方便查找头节点，其他操作时间复杂度同单链表。

### 双向链表

顾名思义，双向链表，除了后继指针外，还有前驱指针保存前一个节点的内存地址。大致如下：

```
-> <prew|data|next> <-> <prew|data|next> <-> <prew|data|next>
```

**查找**

因为双向链表支持双向遍历，在需要查找前驱节点的连续操作时，时间复杂度可以降为O(1)。

**插入**

插入时同单链表，只需关注指针指向即可，时间复杂度为O(1)。

**删除**

双向链表和单链表一样，单说删除操作时，仅仅是移动了节点的指针，时间复杂度为O(1)。但是，删除操作时，我们为了操作指针，需要知道删除节点的前一个节点。单链表和双向链表略有不同：

- 对于单链表，则需要从头遍历，找到后继指针是我们删除节点地址的节点。时间复杂度为O(n)。
- 对于双向链表，则可直接通过前驱指针来获取前驱节点，时间复杂度为O(1)。

### 双向循环链表

双向循环链表，就是把循环链表和双向链表结合起来的一种数据结构。

## 应用

### 数组和链表的性能对比

![](static/imgs/complexity/link.jpg)

- 数组内存空间连续，对CPU的缓存机制友好，CPU可以于都数组的数据，提高访问效率。链表内存不连续，无法连用CPU的缓存机制提高访问效率。
- 数组内存固定，扩容耗时严重。链表没有大小限制，可随意动态扩容。

### 链表应用

- 链表适合插入、删除操作频繁的业务场景
- 双向链表比单链表的插入、删除简单、搞下。
- 循环链表合适要处理的数据具有换新结构特点，如约瑟夫问题。

## 常面试点

- 单链表的反转
- 链表中环的检测。
- 连个有序链表合并。
- 删除链表倒数第N个节点。
- 求链表的中间节点。

注意：
- 指针丢失和内存泄露
- 多用哨兵简化难度
- 留意边界条件处理

## 参考

- 常见的缓存淘汰策略：
  - FIFO（First In，First Out）
  - 最少使用策略 LFU（Least Frequently Used）
  - 最近最少使用策略 LRU（Least Recently Used）