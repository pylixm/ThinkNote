---
type : post
title : 数据结构与算法 - 散列表
categories: [数据结构与算法,] 
series: [数据结构与算法笔记,]
date : 2019-12-25
url: /posts/2019-12-25-hash-table.html 
tags : [数据结构与算法, 散列表]
---

> 《数据结构与算法-王争》学习笔记，记录备查

## 基本概念

散列表，利用数组支持安下标随机访问的数据特性来访问数据。是数组的一种扩展，可以说没有数组就没有散列表。

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过**散列函数把元素的键值映射为下标**，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

## 散列函数

散列函数 **hash(key)**，又叫哈希函数。key 叫做键或者关键字，hash(key)得到值叫做**散列值**。

构造设计散列函数的基本要求：

- 散列函数计算得到的散列值是一个非负整数。
- 如果key1=key2, 那hash(key1)==hash(key2)。
- 如果key2!=key2，那么hash(key1)!=hash(key2)。


前两点很好理解，第三点，当数据量足够大的时候，并不能够完全的保证，不同的key得到的散列值完全不同。而数据的存储空间有限，也会进一步加剧这种冲突。这种冲突有一个名词，叫做**散列冲突**。

**散列冲突**无法根本性的避免，我们需要通过其他方法解决，常用的方法主要有两类：**开放寻址法(open addressing)**和**列表法(chaining)**。

**散列冲突**可以理解为根据散列函数计算出数据下标，向数组中插入数据，当数组中有数据时，即发生散列冲突。

散列冲突的概率可以使用**装载因子**来表示，即散列表的控线位置越少，散列冲突发生的概率便会越大，反之也成立。

装载因子的公式如下：

```
散列表的装载因子=填入表中的元素个数/散列表的长度
```

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。

### 开放寻址法

中心思想，如果出现散列冲突，就重新胎侧一个空闲位置，将元素插入。主要有下面几种方法：

**线性探测**

当数据插入时，根据散列函数得到的下标位置有数据，即发生散列冲突时，往下标大的方向继续探测，直到找到空闲的位置，如果到数组末尾都未找到，则从数据头继续开始查找探测。

当数据查找时，我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。

当删除数据时，不能简单的将数组的值为空，这样会影响查找的正确性。我们把删除的位置标记为**deleted**，这样当查到到该位置时，不会停止退出，而会继续。

**二次探测**

二次探测和线性探测类型，只是步长是原来的二次方而不是1了。

**双重探测**

双重探测，是不仅经过一层散列函数，经过多次散列函数直到直到空闲的位置。



